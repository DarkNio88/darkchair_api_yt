<!doctype html>
<!--
  © 2026 DarkNio
  Licensed under the MIT License. See LICENSE file in project root.
-->
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DarkChair_API_YouTube — Auth</title>
  <style>
    :root{
      --bg:#0f1724; --card:#0b1523; --muted:#9aa4b2; --accent:#4f9ef8; --accent-2:#7de3a8; --glass: rgba(255,255,255,0.04);
      --radius:10px; --gap:14px; --maxwidth:1100px;
    }
    *{box-sizing:border-box}
    body{font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:24px; background:linear-gradient(180deg,#071025 0%, #081426 60%); color:#e6eef6}
    .wrap{max-width:var(--maxwidth);margin:0 auto}
    header{display:flex;align-items:center;gap:12px;margin-bottom:18px}
    h1{font-size:20px;margin:0}
    p.lead{margin:0;color:var(--muted);font-size:13px}

    .grid{display:grid;grid-template-columns:360px 1fr;gap:var(--gap)}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:var(--radius);padding:16px;border:1px solid rgba(255,255,255,0.04)}

    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input[type=text], input[type=password]{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
    .controls{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px}
    button.btn{background:var(--accent);color:#042033;border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    button.danger{background:#ff6b6b;color:#111}
    .small{padding:6px 8px;font-size:13px}

    .preview{display:flex;flex-direction:column;gap:12px}
    .stream-wrap{background:var(--card);border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;min-height:260px}
    #streamImg{max-width:100%;border-radius:6px;display:none;outline:none}

    .status-row{display:flex;align-items:center;gap:10px}
    .badge{background:var(--glass);color:var(--muted);padding:6px 10px;border-radius:999px;font-size:12px}
    .session-item{cursor:pointer;padding:8px;border-radius:6px;background:rgba(255,255,255,0.01);margin-bottom:8px}
    .session-item.active{box-shadow:inset 3px 0 0 var(--accent);background:linear-gradient(90deg, rgba(79,158,248,0.04), transparent)}

    pre#out{background:#02121b;padding:10px;border-radius:8px;color:var(--muted);font-size:13px;overflow:auto;max-height:220px}

    @media(max-width:880px){.grid{grid-template-columns:1fr}.wrap{padding:0 12px}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div style="width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:flex;align-items:center;justify-content:center;font-weight:700">DC</div>
      <div>
        <h1>DarkChair_API_YouTube — Auth</h1>
        <p class="lead">Avvia una sessione browser sul server, effettua il login manuale e poi esporta i cookie per yt-dlp.</p>
      </div>
    </header>

    <div class="grid">
      <div class="card">
        <div class="status-row">
          <div class="badge" id="statusBadge">Not started</div>
          <div style="flex:1"></div>
        </div>

        <div style="margin-top:10px">
          <strong>Active Sessions</strong>
          <div id="sessionsList" style="margin-top:8px;color:var(--muted);font-size:13px">Loading...</div>
        </div>

        <section style="margin-top:12px">
          <strong>Session Controls</strong>
          <div class="controls" style="margin-top:8px">
            <button id="start" class="btn">Start session</button>
          </div>
        </section>

        <section style="margin-top:14px">
          <strong>Stream Preview</strong>
          <div class="controls" style="margin-top:8px">
            <button id="scrollUpBtn" class="ghost small" disabled>▲ Scroll Up</button>
            <button id="scrollDownBtn" class="ghost small" disabled>▼ Scroll Down</button>
          </div>
        </section>

        <!-- Quick Login removed -->

        <section style="margin-top:14px">
          <strong>Diagnostics</strong>
          <pre id="out">output</pre>
        </section>
      </div>

      <div class="preview">
        <div class="card stream-wrap">
          <img id="streamImg" alt="stream preview" tabindex="0" />
        </div>
        <div class="card" style="padding:10px;display:flex;gap:10px;align-items:center">
          <div style="flex:1;color:var(--muted);font-size:13px">Click image to focus and send keyboard input.</div>
          <div style="color:var(--muted);font-size:12px">Stream</div>
        </div>
      </div>
      <div style="text-align:center;margin-top:14px;color:var(--muted);font-size:12px">© 2026 DarkNio — All rights reserved.</div>

    </div>
  </div>

  <script>
    const out = (v)=>{ document.getElementById('out').textContent = typeof v === 'string' ? v : JSON.stringify(v,null,2) };
    const statusBadge = document.getElementById('statusBadge');
    let sessionId = null;

    const setStatus = (s, cls)=>{ statusBadge.textContent = s; };

        document.getElementById('start').onclick = async()=>{
      setStatus('Starting...');
      out('starting...');
      try{
        const r = await fetch('/auth/start',{method:'POST'}).then(res=>res.json());
        if (!r || r.error) { out(r); setStatus('Start failed'); return; }
        sessionId = r.id;
        out(r);
        setStatus('Session active');
            // Quick login removed; no login button to enable
            // refresh sessions list
            try { fetchSessions(); } catch (e) {}
            // auto-start stream shortly after session starts
            setTimeout(()=>{ try { startStream(); } catch(e){} }, 400);
      }catch(e){ out('start error: '+(e && e.message?e.message:String(e))); setStatus('Start error'); }
    };

    // Quick login handler removed

    // session-level actions are available per-item in the sessions list

    // stream control functions (manual start/stop buttons removed)
    async function startStream(){
      if(!sessionId) return out('no session');
      const fps = 10;
      const url = '/auth/stream/'+sessionId+'?fps='+fps;
      const sImg = document.getElementById('streamImg');
      sImg.src = url;
      sImg.style.display = 'block';
      try { document.getElementById('scrollUpBtn').disabled = false; } catch(e){}
      try { document.getElementById('scrollDownBtn').disabled = false; } catch(e){}
      setStatus('Streaming');
      out('stream started');
    }

    async function stopStream(){
      const sImg = document.getElementById('streamImg');
      if (sImg) {
        sImg.src = '';
        sImg.style.display = 'none';
      }
      try { document.getElementById('scrollUpBtn').disabled = true; } catch(e){}
      try { document.getElementById('scrollDownBtn').disabled = true; } catch(e){}
      setStatus('Session active');
      out('stream stopped');
    }

    const enableInputControls = ()=>{ /* no manual stream controls */ };
    const disableInputControls = ()=>{ /* no manual stream controls */ };

    const streamImg = document.getElementById('streamImg');
    streamImg.addEventListener('click', (ev)=>{ if(!sessionId) return out('no session'); streamImg.focus(); });
    streamImg.addEventListener('click', async (ev)=>{
      if(!sessionId) return out('no session');
      const rect = ev.target.getBoundingClientRect();
      const px = (ev.clientX - rect.left) / rect.width;
      const py = (ev.clientY - rect.top) / rect.height;
      const r = await fetch('/auth/mouse/'+sessionId, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ action:'click', px, py }) }).then(r=>r.json());
      out(r);
    });

    const isPrintable = (str) => str.length === 1;
    const keydownHandler = async (ev)=>{
      if(!sessionId) return;
      if (ev.key === 'Shift' || ev.key === 'Control' || ev.key === 'Alt' || ev.key === 'Meta') return;
      ev.preventDefault();
      if (isPrintable(ev.key)) {
        await fetch('/auth/keyboard/'+sessionId, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ type:'type', text: ev.key }) });
      } else {
        let keyName = ev.key;
        await fetch('/auth/keyboard/'+sessionId, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ type:'press', key: keyName }) });
      }
    };

    streamImg.addEventListener('focus', ()=>{ document.addEventListener('keydown', keydownHandler); streamImg.style.outline='2px solid rgba(79,158,248,0.6)'; });
    streamImg.addEventListener('blur', ()=>{ document.removeEventListener('keydown', keydownHandler); streamImg.style.outline='none'; });

    document.getElementById('scrollUpBtn').onclick = async ()=>{ if(!sessionId) return out('no session'); try{ const r = await fetch('/auth/keyboard/'+sessionId, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ type: 'press', key: 'PageUp' }) }).then(r=>r.json()); out(r); }catch(e){ out('scroll error: '+(e && e.message?e.message:String(e))); } };
    document.getElementById('scrollDownBtn').onclick = async ()=>{ if(!sessionId) return out('no session'); try{ const r = await fetch('/auth/keyboard/'+sessionId, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ type: 'press', key: 'PageDown' }) }).then(r=>r.json()); out(r); }catch(e){ out('scroll error: '+(e && e.message?e.message:String(e))); } };

    (function patchEnable(){
      const oldStart = document.getElementById('start').onclick;
      document.getElementById('start').onclick = async()=>{ await oldStart(); enableInputControls(); };
    })();

    // sessions list polling
    async function fetchSessions(){
      try{
        const r = await fetch('/auth/sessions').then(res=>res.json());
        const arr = r.sessions || [];
        const el = document.getElementById('sessionsList');
        if (!arr.length) { el.textContent = 'No active sessions'; return; }
        el.innerHTML = arr.map(s => {
          const dt = s.startedAt ? new Date(s.startedAt).toLocaleString() : '-';
          const url = s.url ? ` • ${s.url}` : '';
          const active = (sessionId === s.id) ? ' active' : '';
          return `<div class="session-item${active}" onclick="selectSession('${s.id}')">
                    <div style="display:flex;justify-content:space-between;align-items:center">
                      <strong style="font-size:13px">${s.id}</strong>
                      <div style="display:flex;gap:6px">
                        <button class="ghost small" onclick="event.stopPropagation(); sessionStatus('${s.id}')">Check</button>
                        <button class="ghost small" onclick="event.stopPropagation(); sessionExport('${s.id}')">Export</button>
                        
                        <button class="danger small" onclick="event.stopPropagation(); sessionClose('${s.id}')">Close</button>
                      </div>
                    </div>
                    <div style="color:var(--muted);font-size:12px;margin-top:6px">started: ${dt}${url}</div>
                  </div>`;
        }).join('');
      }catch(e){ console.error('fetchSessions error', e); }
    }
    // initial load and polling
    try{ fetchSessions(); setInterval(fetchSessions, 5000); } catch (e) {}
    // select a session for preview
    function selectSession(id){
      try { sessionId = id; } catch(e){}
      try { fetchSessions(); } catch(e){}
      try { stopStream(); } catch(e){}
      try { startStream(); } catch(e){}
      setStatus('Selected: '+id);
    }
    
    // per-session actions
    async function sessionStatus(id){
      try{
        const r = await fetch('/auth/status/'+id).then(res=>res.json());
        out(r);
      }catch(e){ out('status error: '+(e && e.message?e.message:String(e))); }
    }

    async function sessionExport(id){
      try{
        const r = await fetch('/auth/export/'+id,{method:'POST'}).then(res=>res.json());
        out(r);
        try{ fetchSessions(); } catch(e){}
      }catch(e){ out('export error: '+(e && e.message?e.message:String(e))); }
    }

    async function sessionClose(id){
      try{
        if (!confirm('Close session '+id+' ?')) return;
        const r = await fetch('/auth/close/'+id,{method:'POST'}).then(res=>res.json());
        out(r);
        // if the closed session was being previewed, stop preview
        if (sessionId === id) { try{ stopStream(); sessionId = null; } catch(e){} }
        try{ fetchSessions(); } catch(e){}
      }catch(e){ out('close error: '+(e && e.message?e.message:String(e))); }
    }

    // previewSession removed — selecting a session already starts the preview
  </script>
</body>
</html>
