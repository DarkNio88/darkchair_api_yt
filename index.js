const { spawn } = require('child_process');
const { PassThrough } = require('stream');
const fs = require('fs');
const path = require('path');

function _cookiesArg(opts = {}) {
  // Otherwise force the use of cookies.txt in the project root (parent of this module)
  const projectRoot = path.resolve(__dirname, '..');
  const cookiesPath = path.join(projectRoot, 'cookies.txt');
  if (!fs.existsSync(cookiesPath)) {
    console.error('darkchair_api_yt: cookies.txt non trovato in project root:', cookiesPath);
  }
  return ['--cookies-from-browser', 'firefox', '--cookies', cookiesPath ];
}

function isAvailable() {
  return new Promise((resolve) => {
    const p = spawn('yt-dlp', ['--version']);
    p.on('error', () => resolve(false));
    p.on('close', (code) => resolve(code === 0));
  });
}

function stream(url, opts = {}) {
  const preferred = opts.format || 'bestaudio/best';
  const fallbacks = [
    'bestaudio/best',
    'bestaudio',
    'best',
    'bestaudio[ext=m4a]/bestaudio',
    'bestaudio[ext=webm]/bestaudio',
    'bestaudio[ext=opus]/bestaudio'
  ];
  const cookies = _cookiesArg(opts);

  const outStream = new PassThrough();
  let tried = 0;
  let currentProc = null;

  const trySpawn = (fmt) => {
    const args = ['-o', '-', '-f', fmt, '--no-playlist', '--no-warnings', url];
    if (cookies.length) args.splice(0, 0, ...cookies);
    const proc = spawn('yt-dlp', args, { stdio: ['ignore', 'pipe', 'pipe'] });
    currentProc = proc;

    proc.on('error', (e) => {
      console.error('darkchair_api_yt: yt-dlp spawn error for', url, e && e.message ? e.message : e);
    });

    proc.stderr.on('data', (d) => {
      const msg = String(d).trim();
      if (msg) console.error('darkchair_api_yt yt-dlp stderr:', msg);
    });

    // pipe stdout into our pass-through without ending it (we manage end)
    if (proc.stdout) proc.stdout.pipe(outStream, { end: false });

    proc.on('close', (code, signal) => {
      if (code === 0) {
        // streaming finished normally
        try { outStream.end(); } catch (e) {}
      } else {
        // try next fallback if available
        tried += 1;
        if (tried < fallbacks.length) {
          const nextFmt = fallbacks[tried];
          console.warn('darkchair_api_yt: format failed, retrying with', nextFmt);
          trySpawn(nextFmt);
        } else {
          console.error(`darkchair_api_yt: yt-dlp exited with code=${code} signal=${signal} for ${url}`);
          try { outStream.end(); } catch (e) {}
        }
      }
    });

    return proc;
  };

  // start first attempt (preferred format first)
  const firstFmt = preferred || fallbacks[0];
  const proc = trySpawn(firstFmt);

  return { stream: outStream, proc: { current: () => currentProc } };
}

async function getInfo(url, opts = {}) {
  return new Promise((resolve) => {
    const args = ['--dump-json', '--no-playlist', '--no-warnings', url];
    const cookies = _cookiesArg(opts);
    if (cookies.length) args.splice(0, 0, ...cookies);
    console.log('darkchair_api_yt: getInfo spawn yt-dlp with args:', args.join(' '));
    const proc = spawn('yt-dlp', args, { stdio: ['ignore', 'pipe', 'pipe'] });
    let out = '';
    proc.stdout.on('data', (d) => { out += d.toString(); });
    proc.on('error', () => resolve(null));
    proc.on('close', (code) => {
      if (code === 0 && out) {
        try { resolve(JSON.parse(out)); } catch (e) { resolve(null); }
      } else resolve(null);
    });
  });
}

// isAuthenticated removed: avoid running yt-dlp format selection during auth checks

// --- Auth server integration (lazy-loads puppeteer to avoid heavy startup) ---
const express = require('express');
const crypto = require('crypto');
// Project root is parent of this module
const PROJECT_ROOT = path.resolve(__dirname, '..');
const COOKIES_FILE = path.join(PROJECT_ROOT, 'cookies.txt');

function makeId() { return crypto.randomBytes(6).toString('hex'); }

function cookiesToNetscape(cookies) {
  const lines = ['# Netscape HTTP Cookie File', '# Generated by darkchair_api_yt/index.js'];
  for (const c of cookies) {
    const domain = c.domain || c.hostname || '';
    const flag = domain.startsWith('.') ? 'TRUE' : 'FALSE';
    const pathVal = c.path || '/';
    const secure = c.secure ? 'TRUE' : 'FALSE';
    // Some cookie sources use -1 or invalid expires; Netscape format expects a non-negative integer
    const rawExpires = (typeof c.expires === 'number') ? Math.floor(c.expires) : 0;
    const expires = rawExpires > 0 ? rawExpires : 0;
    const name = c.name || c.key || '';
    const value = c.value || '';
    lines.push([domain, flag, pathVal, secure, expires, name, value].join('\t'));
  }
  return lines.join('\n') + '\n';
}

function createAuthApp() {
  const app = express();
  // serve simple auth UI
  app.use('/auth/ui', express.static(path.join(__dirname, 'public')));
  app.use(express.json());
  const SESSIONS = new Map();

  app.post('/auth/start', async (req, res) => {
    const id = makeId();
    try {
      const puppeteer = require('puppeteer-extra');
      const StealthPlugin = require('puppeteer-extra-plugin-stealth');
      const stealth = StealthPlugin();
      try { stealth.enabledEvasions.delete('iframe.contentWindow'); } catch (e) {}
      try { stealth.enabledEvasions.delete('media.codecs'); } catch (e) {}
      puppeteer.use(stealth);
      const headlessEnv = process.env.AUTH_HEADLESS;
      const headless = headlessEnv === '1' || headlessEnv === 'true';
      const debugPort = process.env.AUTH_DEBUG_PORT || '9222';
      const debugHost = process.env.AUTH_DEBUG_HOST || '127.0.0.1';
      const execPath = process.env.PUPPETEER_EXEC || process.env.PUPPETEER_EXEC_PATH || undefined;
      const product = process.env.PUPPETEER_PRODUCT || 'firefox';
      const userAgent = process.env.AUTH_USER_AGENT || (product === 'firefox'
        ? 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0'
        : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36');

      const launchArgs = [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--no-first-run',
        '--no-default-browser-check',
        '--disable-dev-shm-usage',
        '--disable-blink-features=AutomationControlled'
      ];

      // only add Chrome-specific remote-debugging flags when using Chrome
      if (product === 'chrome') {
        launchArgs.push(`--remote-debugging-port=${debugPort}`);
        launchArgs.push(`--remote-debugging-address=${debugHost}`);
      }

      const launchOpts = { headless, args: launchArgs, product };
      if (execPath) launchOpts.executablePath = execPath;
      // support persistent profile (user-data-dir) to keep session across restarts
      const profileDir = process.env.PUPPETEER_PROFILE || process.env.PUPPETEER_USER_DATA_DIR || null;
      if (profileDir) launchOpts.userDataDir = profileDir;

      const browser = await puppeteer.launch(launchOpts);
      const page = await browser.newPage();
      // set UA and override automation flags before navigation
      await page.setUserAgent(userAgent);
      await page.evaluateOnNewDocument(() => {
        try {
          // Fake plugins array (basic shape similar to Chrome)
          const fakePlugins = [
            { name: 'Chrome PDF Plugin', filename: 'internal-pdf-viewer', description: 'Portable Document Format' },
            { name: 'Chrome PDF Viewer', filename: 'mhjfbmdgcfjbbpaeojofohoefgiehjai', description: 'Portable Document Format' }
          ];
          const pluginArray = fakePlugins;
          pluginArray.item = function(i) { return this[i] || null; };
          pluginArray.namedItem = function(name) { return this.find(p => p.name === name) || null; };
          Object.defineProperty(pluginArray, 'length', { get: function() { return Array.prototype.length.call(this); }, configurable: true });
          Object.defineProperty(navigator, 'plugins', { get: () => pluginArray, configurable: true });

          // Basic mimeTypes stub
          const fakeMimeTypes = [];
          //Object.defineProperty(navigator, 'mimeTypes', { get: () => fakeMimeTypes, configurable: true });

          // window.chrome
          window.chrome = window.chrome || { runtime: {} };

          // hardware / device properties
          Object.defineProperty(navigator, 'hardwareConcurrency', { get: () => 4, configurable: true });
          Object.defineProperty(navigator, 'deviceMemory', { get: () => 8, configurable: true });
          Object.defineProperty(navigator, 'maxTouchPoints', { get: () => 0, configurable: true });

          // Permissions.query shim for notifications
          try {
            if (navigator.permissions && navigator.permissions.query) {
              const origQuery = navigator.permissions.query.bind(navigator.permissions);
              navigator.permissions.query = (parameters) => {
                if (parameters && parameters.name === 'notifications') {
                  return Promise.resolve({ state: Notification && Notification.permission ? Notification.permission : 'default' });
                }
                return origQuery(parameters);
              };
            }
          } catch (e) {}

          // Spoof WebGL vendor/renderer
          try {
            const getParameter = WebGLRenderingContext.prototype.getParameter;
            WebGLRenderingContext.prototype.getParameter = function(param) {
              if (param === 37445) return 'Intel Inc.'; // UNMASKED_VENDOR_WEBGL
              if (param === 37446) return 'Intel Iris'; // UNMASKED_RENDERER_WEBGL
              return getParameter.call(this, param);
            };
          } catch (e) {}

        } catch (e) {}
      });
      // Additional stronger spoofing injected on each new document
      await page.evaluateOnNewDocument(() => {
        try {
          // navigator.userAgentData emulation
          try {
            if (typeof navigator.userAgentData === 'undefined') {
              Object.defineProperty(navigator, 'userAgentData', { get: () => ({
                brands: [{ brand: 'Chromium', version: '117' }, { brand: 'Google Chrome', version: '117' }],
                mobile: false,
                getHighEntropyValues: (hints) => Promise.resolve({
                  platform: 'Windows',
                  architecture: 'x64',
                  model: '',
                  uaFullVersion: (navigator.userAgent && navigator.userAgent.match(/Chrome\/(\d+\.\d+\.\d+\.\d+)/) && navigator.userAgent.match(/Chrome\/(\d+\.\d+\.\d+\.\d+)/)[1]) || '117.0.0.0'
                })
              }), configurable: true });
            }
          } catch (e) {}

          // window.chrome helpers
          try { window.chrome = window.chrome || {}; window.chrome.runtime = window.chrome.runtime || {}; window.chrome.webstore = window.chrome.webstore || {}; } catch(e){}

          // Strengthen permissions.query shim
          try {
            const perms = navigator.permissions;
            if (perms && perms.query) {
              const orig = perms.query.bind(perms);
              perms.query = (params) => {
                if (params && params.name === 'notifications') return Promise.resolve({ state: Notification && Notification.permission ? Notification.permission : 'default' });
                return orig(params);
              };
            }
          } catch (e) {}

          // Attempt to mask patched functions as native
          try {
            const nativeToString = Function.prototype.toString;
            const oldToString = nativeToString.call.bind(nativeToString);
            Function.prototype.toString = function() {
              try {
                if (this && this.name && (this.name === 'getParameter' || this.name === 'query')) {
                  return 'function ' + (this.name || '') + '() { [native code] }';
                }
              } catch (e) {}
              return oldToString(this);
            };
          } catch (e) {}

          // Provide more realistic Plugin/MimeType objects
          try {
            const makePlugin = (p) => ({ name: p.name || '', filename: p.filename || '', description: p.description || '' });
            const fake = [];
            //Object.defineProperty(navigator, 'plugins', { get: () => fake, configurable: true });
            //Object.defineProperty(navigator, 'mimeTypes', { get: () => [], configurable: true });
          } catch(e){}

        } catch (e) {}
      });
      await page.goto('https://accounts.google.com/ServiceLogin?service=youtube', { waitUntil: 'networkidle2' });
      SESSIONS.set(id, { browser, page, startedAt: Date.now() });
      const ws = browser.wsEndpoint ? browser.wsEndpoint() : null;
      const httpJsonUrl = `http://${debugHost}:${debugPort}/json`;
      res.json({ id, message: 'Browser opened. Complete login in the opened window on the server.', wsEndpoint: ws, debugPort, httpJsonUrl });
    } catch (e) {
      const msg = e && e.message ? e.message : String(e);
      console.error('auth-server: start error', msg, e && e.stack ? e.stack : '');
      res.status(500).json({ error: 'failed to start browser', detail: msg });
    }
  });

      app.post('/auth/export/:id', async (req, res) => {
    const id = req.params.id;
    const sess = SESSIONS.get(id);
    if (!sess) return res.status(404).json({ error: 'session not found' });
    try {
      const { page, browser } = sess;
      const cookies = await page.cookies('https://www.youtube.com');
      let list = cookies;
      if (!cookies || cookies.length === 0) {
        try {
          const all = await page._client.send('Network.getAllCookies');
          list = all && all.cookies ? all.cookies : [];
        } catch (e) {
          list = [];
        }
      }
      const out = cookiesToNetscape(list);
      fs.writeFileSync(COOKIES_FILE, out, 'utf8');
      // If a persistent profile is used, keep the browser open so session persists.
      const profileDir = process.env.PUPPETEER_PROFILE || process.env.PUPPETEER_USER_DATA_DIR || null;
      if (!profileDir) {
        try { await browser.close(); } catch (e) {}
        SESSIONS.delete(id);
      } else {
        // keep session in memory mapped so user can continue using it
        // update startedAt to now
        sess.startedAt = Date.now();
        SESSIONS.set(id, sess);
      }
      return res.json({ saved: true, cookies: list.length });
    } catch (e) {
      console.error('auth-server: export error', e && e.message ? e.message : e);
      return res.status(500).json({ error: 'failed to export cookies' });
    }
  });

  app.get('/auth/status/:id', (req, res) => {
    const id = req.params.id;
    const sess = SESSIONS.get(id);
    if (!sess) return res.status(404).json({ error: 'session not found' });
    res.json({ id, startedAt: sess.startedAt });
  });

    // GET /auth/tests/:id -> run stealth detection checks on the page
    async function runStealthChecks(page) {
      try {
        const result = await page.evaluate(async () => {
          const out = {};
          out.webdriver = !!navigator.webdriver;
          out.userAgent = navigator.userAgent || null;
          out.languages = navigator.languages || null;
          out.pluginsLength = (navigator.plugins && navigator.plugins.length) ? navigator.plugins.length : 0;
          out.hasChrome = !!window.chrome;
          out.vendor = navigator.vendor || null;
          out.platform = navigator.platform || null;
          out.doNotTrack = navigator.doNotTrack || null;
          try {
            if (navigator.permissions && navigator.permissions.query) {
              const p = await navigator.permissions.query({ name: 'notifications' });
              out.notificationsPermission = p && p.state ? p.state : null;
            } else {
              out.notificationsPermission = null;
            }
          } catch (e) { out.notificationsPermission = 'error'; }
          // detect webdriver in userAgent
          out.uaContainsHeadless = /HeadlessChrome|PhantomJS/i.test(navigator.userAgent);
          // basic fonts/webgl checks could be added here
          return out;
        });
        return { ok: true, checks: result };
      } catch (e) {
        return { ok: false, error: e && e.message ? e.message : String(e) };
      }
    }

    app.get('/auth/tests/:id', async (req, res) => {
      const id = req.params.id;
      const sess = SESSIONS.get(id);
      if (!sess) return res.status(404).json({ error: 'session not found' });
      try {
        const r = await runStealthChecks(sess.page);
        res.json(r);
      } catch (e) {
        res.status(500).json({ error: 'tests failed', detail: e && e.message ? e.message : String(e) });
      }
    });

    // POST /auth/navigate/:id -> navigate the session page to a given URL
    app.post('/auth/navigate/:id', async (req, res) => {
      const id = req.params.id;
      const sess = SESSIONS.get(id);
      if (!sess) return res.status(404).json({ error: 'session not found' });
      try {
        const body = req.body || {};
        const url = body.url || req.query.url;
        if (!url || typeof url !== 'string') return res.status(400).json({ error: 'missing url' });
        if (!/^https?:\/\//i.test(url)) return res.status(400).json({ error: 'invalid url scheme' });
        await sess.page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
        return res.json({ ok: true, url });
      } catch (e) {
        console.error('auth-server: navigate error', e && e.message ? e.message : e);
        return res.status(500).json({ error: 'navigate failed', detail: e && e.message ? e.message : String(e) });
      }
    });
  // GET /auth/screenshot/:id -> single PNG screenshot of the auth page
  app.get('/auth/screenshot/:id', async (req, res) => {
    const id = req.params.id;
    const sess = SESSIONS.get(id);
    if (!sess) return res.status(404).json({ error: 'session not found' });
    try {
      const { page } = sess;
      const buf = await page.screenshot({ type: 'png', fullPage: false });
      res.setHeader('Content-Type', 'image/png');
      res.setHeader('Cache-Control', 'no-cache');
      return res.send(buf);
    } catch (e) {
      console.error('auth-server: screenshot error', e && e.message ? e.message : e);
      return res.status(500).json({ error: 'failed to capture screenshot', detail: e && e.message ? e.message : String(e) });
    }
  });

  // GET /auth/stream/:id -> multipart/x-mixed-replace (MJPEG) stream of repeated screenshots
  app.get('/auth/stream/:id', async (req, res) => {
    const id = req.params.id;
    const sess = SESSIONS.get(id);
    if (!sess) return res.status(404).json({ error: 'session not found' });
    const fps = Math.max(1, parseInt(req.query.fps || '1', 10));
    const intervalMs = Math.round(1000 / fps);
    res.writeHead(200, {
      'Content-Type': 'multipart/x-mixed-replace; boundary=frame',
      'Cache-Control': 'no-cache',
      'Connection': 'close'
    });

    let stopped = false;
    req.on('close', () => { stopped = true; });

    const captureAndWrite = async () => {
      if (stopped) return;
      try {
        const buf = await sess.page.screenshot({ type: 'jpeg', quality: 60 });
        res.write('--frame\r\n');
        res.write('Content-Type: image/jpeg\r\n');
        res.write('Content-Length: ' + buf.length + '\r\n\r\n');
        res.write(buf);
        res.write('\r\n');
      } catch (e) {
        console.error('auth-server: stream capture error', e && e.message ? e.message : e);
        stopped = true;
        try { res.end(); } catch (er) {}
      }
    };

    // initial capture then periodic
    await captureAndWrite();
    const timer = setInterval(() => { if (!stopped) captureAndWrite(); else clearInterval(timer); }, intervalMs);
  });

  // POST /auth/keyboard/:id -> { type: 'type'|'press', text, key }
  app.post('/auth/keyboard/:id', async (req, res) => {
    const id = req.params.id;
    const sess = SESSIONS.get(id);
    if (!sess) return res.status(404).json({ error: 'session not found' });
    try {
      const { page } = sess;
      const body = req.body || {};
      if (body.type === 'type' && typeof body.text === 'string') {
        await page.keyboard.type(body.text, { delay: body.delay || 0 });
        return res.json({ ok: true });
      }
      if (body.type === 'press' && typeof body.key === 'string') {
        await page.keyboard.press(body.key, { delay: body.delay || 0 });
        return res.json({ ok: true });
      }
      return res.status(400).json({ error: 'invalid payload' });
    } catch (e) {
      console.error('auth-server: keyboard error', e && e.message ? e.message : e);
      return res.status(500).json({ error: 'keyboard failed', detail: e && e.message ? e.message : String(e) });
    }
  });

  // POST /auth/mouse/:id -> { action: 'click'|'move'|'down'|'up', px, py, button }
  // px/py are percentages in [0,1] relative to the page viewport (or image shown)
  app.post('/auth/mouse/:id', async (req, res) => {
    const id = req.params.id;
    const sess = SESSIONS.get(id);
    if (!sess) return res.status(404).json({ error: 'session not found' });
    try {
      const { page } = sess;
      const body = req.body || {};
      const action = body.action || 'click';
      const button = body.button || 'left';

      // determine viewport size
      let vw = null;
      let vh = null;
      if (page.viewport && page.viewport()) {
        const vp = page.viewport(); if (vp) { vw = vp.width; vh = vp.height; }
      }
      if (!vw || !vh) {
        const dims = await page.evaluate(() => ({ w: window.innerWidth, h: window.innerHeight }));
        vw = dims.w; vh = dims.h;
      }

      const px = typeof body.px === 'number' ? body.px : 0.5;
      const py = typeof body.py === 'number' ? body.py : 0.5;
      const x = Math.round(Math.max(0, Math.min(1, px)) * (vw || 1));
      const y = Math.round(Math.max(0, Math.min(1, py)) * (vh || 1));

      if (action === 'click') {
        await page.mouse.click(x, y, { button: button, clickCount: body.clickCount || 1 });
        return res.json({ ok: true, x, y });
      }
      if (action === 'move') {
        await page.mouse.move(x, y);
        return res.json({ ok: true, x, y });
      }
      if (action === 'down') { await page.mouse.down({ button }); return res.json({ ok: true }); }
      if (action === 'up') { await page.mouse.up({ button }); return res.json({ ok: true }); }

      return res.status(400).json({ error: 'invalid mouse action' });
    } catch (e) {
      console.error('auth-server: mouse error', e && e.message ? e.message : e);
      return res.status(500).json({ error: 'mouse failed', detail: e && e.message ? e.message : String(e) });
    }
  });

  app.post('/auth/close/:id', async (req, res) => {
    const id = req.params.id;
    const sess = SESSIONS.get(id);
    if (!sess) return res.status(404).json({ error: 'session not found' });
    try { await sess.browser.close(); } catch (e) {}
    SESSIONS.delete(id);
    res.json({ closed: true });
  });

  return app;
}

async function startAuthServer(port = process.env.AUTH_PORT || 3001) {
  const app = createAuthApp();
  return new Promise((resolve, reject) => {
    const s = app.listen(port, (err) => {
      if (err) return reject(err);
      console.log('darkchair_api_yt auth-server listening on', port);
      resolve(s);
    });
  });
}

if (require.main === module) {
  startAuthServer().catch((e) => console.error('failed to start auth-server:', e && e.message ? e.message : e));
}

module.exports = { isAvailable, stream, getInfo, startAuthServer, createAuthApp };
